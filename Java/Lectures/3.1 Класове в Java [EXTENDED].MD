# Класове в Java - Наследяване. Създаване и използване на обекти.

### 1\. Въведение в Класове и Обекти

Лекцията започва с разграничаването на примитивни и референтни типове данни в Java. В ООП (Обектно-ориентираното програмиране) основната идея е описването на света чрез обекти, които се създават по предварително дефиниран шаблон (клас).

  * **Клас:** Дефинира се като "съвкупност от описания на възможните състояния... и на възможните действия..., които може да извършва, даден тип обект от реалността". Класът е шаблонът.
  * **Обект:** Дефинира се като "конкретен екземпляр, създаден по предварително направената дефиниция на даден клас".

### 2\. Какво съдържа един клас?

Всеки клас съдържа два основни типа елементи, които описват обектите, създадени от него:

1.  **Променливи (Полета):** Описват *състоянието* на обекта (напр. цвят, височина, име). Всеки обект (инстанция) има свои собствени стойности за тези полета.
2.  **Методи:** Описват *поведението* на обекта (напр. "лаене", "писане", "изчисляване").

### 3\. Елементи на класа

Тялото на класа се загражда с къдрави скоби `{ }` и съдържа следните елементи:

#### Декларация

Редът, който дефинира името на класа и неговата видимост (модификатор за достъп). Името на класа по стандарт започва с главна буква.

```java
public class Person {
    // ... тяло на класа ...
}
```

#### Модификатори за достъп

Ключови думи, които определят видимостта на класове, полета и методи.

  * `public`: Видимост навсякъде (в класа, пакета, наследниците, други пакети).
  * `protected`: Видимост в класа, в пакета и в наследниците.
  * `private`: Видимост *само* в рамките на класа.
  * *(без модификатор)* (package-private): Видимост само в класа и в пакета.

**[ТАБЛИЦА: Модификатори за достъп]**
Следва таблица, която обобщава нивата на достъп:

| Modifier | Class | Package | Subclass | World |
| :--- | :---: | :---: | :---: | :---: |
| `public` | Y | Y | Y | Y |
| `protected` | Y | Y | Y | N |
| `no modifier` | Y | Y | N | N |
| `private` | Y | N | N | N |

#### Конструктор

Псевдометод, използван за създаване (инициализиране) на нови обекти от този клас.

  * **Изисквания:**
    1.  Името му *съвпада* с името на класа.
    2.  Няма тип на връщания резултат (дори не `void`).
    3.  Обикновено е `public` или `protected`.
  * **Конструктор по подразбиране:** Ако не напишете изрично конструктор, Java създава един "default" конструктор без параметри.
  * **Внимание:** Ако създадете *какъвто и да е* конструктор (напр. с параметри), конструкторът по подразбиране *вече не съществува* автоматично.

*Примери за конструктори:*

```java
// Конструктор без параметри
public Person() {
    // ...
}

// Конструктор с параметри
public Person(String name) {
    // ...
}
```

#### Полета (Fields)

Променливите, които описват състоянието.

  * **Статични полета (static):** Декларират се с ключовата дума `static`. Те са *общи* за всички инстанции (обекти) на класа. Промяната им от един обект се отразява при всички.

*Пример за полета:*

```java
private String name; // Поле за инстанция
protected int yearOfBirth; // Поле за инстанция
private static int numb = 5; // Статично поле
```

#### Методи (Methods)

Описват поведението.

*Пример за метод:*

```java
public void speak() {
    System.out.println("Hi, my name is " + name);
}
```

#### Get и Set методи (Аксесори и Мутатори)

Използват се за принципа на **капсулация (encapsulation)** – скриване на данни.

  * **Стратегия:** Полетата се декларират като `private`. Достъпът до тях (четене и промяна) се осъществява контролирано чрез `public` get и set методи.
  * `get` методите (аксесори) връщат стойността на полето.
  * `set` методите (мутатори) задават нова стойност, като позволяват *валидация* (проверка) на данните преди задаването им.

*Пример за Get/Set:*

```java
public String getName() {
    return this.name;
}

public void setName(String name) {
    // Тук може да има валидация, напр. name да не е null
    this.name = name;
}
```

  * **Ключова дума `this`:** Използва се за достъп до нестатичен елемент (поле или метод) на *текущия* клас. В примера `this.name = name;`, `this.name` е полето на класа, а `name` е параметърът, подаден на метода.

#### [КОД: Един готов клас]

Лекцията предоставя пълен пример за клас `Person`, който обединява всички тези елементи:

```java
package javaExamples;

public class Person {
    private String name;
    private int yearOfBirth;

    // Конструктор по подразбиране
    public Person() {
        this.name = "";
        this.yearOfBirth = 0;
    }

    // Конструктор с параметри
    public Person(String name, int yearOfbirth) {
        this.name = name;
        this.yearOfBirth = yearOfbirth;
    }

    // Get и Set методи
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getYearOfBirth() {
        return yearOfBirth;
    }

    public void setYearOfBirth(int yearOfBirth) {
        this.yearOfBirth = yearOfBirth;
    }

    // Метод за поведение
    public void speak() {
        System.out.println("Hi, my name is " + getName());
    }
}
```

-----

### 4\. Наследяване (Inheritance)

Наследяването описва йерархията между обектите (видове и подвидове).

  * **Single Inheritance (Единично наследяване):** В Java, един клас може да наследи (да бъде "дете" на) *НЕ повече от един* друг клас. (Това е разлика спрямо C++, който поддържа множествено наследяване).
  * **Правила при наследяване:**
    1.  Дъщерният клас (child) получава достъп до всички `public` и `protected` полета и методи на родителския клас (parent).
    2.  Родителският клас *няма* достъп до елементите на дъщерния.
    3.  Дъщерният клас трябва да "разшири" родителския (да добави нови полета или методи).
    4.  Родителският клас не трябва да е `final`.
    5.  Родителският клас не трябва да е `private`.

#### [КОД: Пример за наследяване]

Наследяването става с ключовата дума `extends`.

```java
public class Worker extends Person {
    // Полета само за Worker...

    public Worker() {
        super(); // Задължително извикване на конструктора на родителя
    }

    // Методи само за Worker...
}
```

  * **Обяснение на `super()`:** Извикването на `super();` е задължително и трябва да е на *първия ред* в конструктора на дъщерния клас. То извиква конструктора на родителския клас (`Person` в случая), за да се инициализират и неговите полета.

-----

### 5\. Създаване и използване на обекти

#### Създаване и инициализиране

1.  **Декларация:** `Person person;`
      * Това *само* създава променлива (референция) `person`. Тъй като е референтен тип, стойността ѝ по подразбиране е `null` (не сочи към обект).
2.  **Инициализация (Създаване на обект):**
      * Използва се ключовата дума `new`, която заделя памет за обекта, последвана от конструктора на класа.
      * `Person person = new Person();` (Използва конструктора без параметри)
      * `Person person = new Person("Ivan", 25);` (Използва конструктора с параметри)

#### Извикване на метод на обект

  * **Метод на инстанция:** Достъпва се с точка (`.`) през променливата (обекта).
      * `obj.objMethod();`
  * **Статичен метод:** Достъпва се с точка (`.`) през *името на класа* (тъй като е общ за класа, а не за конкретен обект).
      * `Person.someStaticMethod();`

#### Важно (NullPointerException)

  * **NullPointerException:** Това е грешка (exception), която възниква, ако се опитате да извикате метод или да достъпите поле на обект, който е `null` (неинициализиран).
      * `Person person;`
      * `person.speak();` // Това ще хвърли NullPointerException
  * **Garbage Collector (Система за почистване):** Когато един обект "излезе от обхват" (например методът, в който е създаден, приключи), системата Garbage Collector автоматично го унищожава и освобождава паметта.

-----

### 6\. Задачи

  * **Задача 1:**

    1.  Да се напише клас `Company` (с полета: име, дата на създаване, Булстат).
    2.  Булстат полето да има валидация в `set`-метода (дължина 10).
    3.  Да се напише клас `Фирма-ЕТ`, който наследява `Company`.
    4.  `Фирма-ЕТ` да има допълнителни полета (собственик, първоначален капитал, актуален капитал).
    5.  `Фирма-ЕТ` да има метод за изчисляване на печалбата (разликата между актуален и първоначален капитал).

  * **Задача 2:**

    1.  Да се създаде клас `Car` (марка, модел, цвят, мощност, двигател, скорости, година) с get/set методи и конструктори.
    2.  Метод 1: Приема масив от коли и буква; връща нов масив само с колите, чиято марка започва с тази буква.
    3.  Метод 2: Приема масив от коли; връща сортиран масив (възходящо/низходящо) по марка.
    4.  Метод 3: Приема масив от коли; връща "прочистен" масив без повтарящи се коли.
    5.  Да се създаде `Test` клас с `main` метод за тестване на горните методи.