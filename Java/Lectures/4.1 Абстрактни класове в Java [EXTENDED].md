# Абстракция, Интерфейси и Полиморфизъм в Java

## 1\. Абстрактни класове

Абстрактен клас е клас, деклариран с `abstract`, който може да съдържа както абстрактни (без тяло), така и конкретни (с тяло) методи.

-----

### 1.1 Деклариране

```java
// Декларация с ключовата дума abstract
public abstract class AbstractClassExample {
    
    // Конкретен метод: има тяло
    public void someMethod() {
        // Statements here
    }

    // Абстрактен метод: без тяло, завършва с ;
    public abstract void firstaAbstractMethod();
}
```

  - **Обяснение на кода:**
      - `abstract` метод (`firstaAbstractMethod`) съдържа само декларация, но няма имплементация (тяло).
      - Ако един клас има поне един `abstract` метод, класът задължително трябва да бъде деклариран като `abstract`.
      - `someMethod` е конкретен (неабстрактен) метод, тъй като има имплементация (тяло `{}`).

-----

### 1.2 Наследяване и Имплементация

```java
public abstract class Figure {
    public abstract double area(float a, float b);
}

class Triangle extends Figure {
    @Override
    public double area(float a, float b) {
        return a * b / 2;
    }
}

class Rectangle extends Figure {
    @Override
    public double area(float a, float b) {
        return a * b;
    }
}
```

  - **Обяснение на кода:**
      - `Figure` е абстрактен клас, който дефинира абстрактно поведение `area`.
      - `Triangle` и `Rectangle` наследяват `Figure` и предоставят *конкретна* имплементация за `area`, тъй като изчислението е различно за всяка фигура. `@Override` показва, че методът се имплементира от родителския клас.

-----

### 1.3 Важни правила

  - **Абстрактен клас не може да се инстанцира\!** (Не може да се направи `new Figure()`). Може само да се наследява.
  - Ако даден клас наследи абстрактен клас, той **задължително трябва да имплементира всички** абстрактни методи.
      - *Изключение:* Ако класът-наследник също е `abstract`, той не е длъжен да ги имплементира (прехвърля задължението).

-----

### 1.4 Защо са необходими?

  - Те обобщават функционалност и белези.
  - **Пример:** Клас `Животно` е `abstract`. Няма смисъл да се създава обект "Животно". Наследниците `Куче` и `Котка` са конкретни.
  - Ако `Животно` има `abstract` метод `издаванеНаЗвук()`, `Куче` ще го имплементира като "Бау-бау", а `Котка` като "Мяу-мяу". Абстрактният клас `Животно` не знае какъв звук да издаде.

-----

## 2\. Интерфейси

Интерфейсът е подобен на абстрактен клас, но (традиционно) съдържа само абстрактни методи и константни променливи.

-----

### 2.1 Деклариране

```java
public interface FirstInterface {
    /* * Всички методи по подразбиране са 
     * public abstract.
     * Не е нужно да се изписва.
     */
    void method1(); // еквивалентно на public abstract void method1();
    void method2();
}
```

  - **Обяснение на кода:**
      - Декларира се с `interface`.
      - Методите **нямат тяло** и по подразбиране са `public abstract`.

-----

### 2.2 Имплементация

```java
public interface MyInterface {
    public abstract void method1();
    public abstract void method2();
}

public class XYZ implements MyInterface {
    
    // Класът е длъжен да имплементира ВСИЧКИ методи
    public void method1() {
        System.out.println("implementation of method1");
    }

    public void method2() {
        System.out.println("implementation of method2");
    }

    public static void main(String arg[]) {
        MyInterface obj = new XYZ();
        obj.method1();
    }
}
```

  - **Обяснение на кода:**
      - Клас "наследява" интерфейс с ключовата дума `implements`.
      - Класът `XYZ` **трябва** да имплементира (да напише тяло) за `method1` и `method2`.
      - В `main` метода се вижда как обект от тип `XYZ` се съхранява в променлива от типа на интерфейса (`MyInterface`).

-----

### 2.3 Интерфейси с променливи

```java
interface Try {
    public int b = 10;
    final int d = 10;
    static int e = 0;
    public static final int c = 10;
    int a = 10; // Всички са идентични
}
```

  - **Обяснение на кода:**
      - Всички променливи, дефинирани в интерфейс, са **по подразбиране `public static final`** (публични, статични константи).
      - Те **трябва** да бъдат инициализирани по време на декларацията.
      - Стойността им не може да се променя.

-----

### 2.4 Наследяване на интерфейси

```java
public interface Inf1 {
    public abstract void method1();
}

// Inf2 наследява Inf1
public interface Inf2 extends Inf1 {
    public abstract void method2();
}

// Demo имплементира Inf2 (и индиректно Inf1)
public class Demo implements Inf2 {
    
    // Трябва да имплементира method1 (от Inf1)
    public void method1() {
        // Implementation of method1
    }
    
    // Трябва да имплементира method2 (от Inf2)
    public void method2() {
        // Implementation of method2
    }
}
```

  - **Обяснение на кода:**
      - Интерфейс може да **наследи** друг интерфейс чрез `extends` (не `implements`).
      - Когато клас `implements` `Inf2`, той трябва да имплементира методите и на `Inf2`, и на всички негови "родители" (в случая `Inf1`).

-----

### 2.5 Важни правила

  - **Интерфейс не може да се инстанцира\!**
  - **Множествено наследяване:** Един клас може да имплементира **множество интерфейси** (`class MyClass implements Inf1, Inf2`). Това е начинът Java да постигне множествено наследяване на "поведение".
  - **Java 8 `default` методи:** От Java 8 интерфейсите могат да имат и **конкретни** методи, декларирани с `default`. Това позволява добавяне на функционалност по подразбиране.
  - **Конфликт на методи:**
      - Ако два интерфейса имат еднакви методи, класът ги имплементира **само веднъж**.
      - **ГРЕШКА:** Ако два интерфейса имат методи с **еднакво име, но различен тип на връщан резултат**, те не могат да бъдат имплементирани от един и същи клас.

<!-- end list -->

```java
interface A {
    public abstract void aaa();
}
interface B {
    public abstract int aaa(); // Същото име, различен тип (int)
}

// Този клас НЕ може да се компилира
class Central implements A, B {
    // Невъзможно е да се имплементират и двата метода
    public void aaa() { ... } // error
    public int aaa() { ... }  // error
}
```

  - **Конфликт на променливи:** Ако има съвпадащи имена на променливи, те се достъпват статично чрез името на интерфейса (напр. `A.myVar`).

-----

## 3\. Полиморфизъм

Полиморфизъм означава "много форми". В ООП това се интерпретира като "един интерфейс – много методи (имплементации)".

-----

### 3.1 Обяснение

  - Това е способността на различни обекти да извършват **едно и също действие** (извикване на метод) по **различен начин**.
  - **Пример (Превозни средства):**
      - Всички превозни средства (кола, тир, автобус) имат общо действие "движение".
      - Всички имат общ "интерфейс" (волан, скорости, мигачи).
      - Въпреки това, "движението" се извършва по различен начин при всеки (различен двигател, устройство).
  - **Практически пример (от лекцията):**
      - Примерът с `Figure` е полиморфизъм.
      - "Интерфейсът" е методът `area()`.
      - "Многото форми" са различните имплементации:
          - `Triangle` го имплементира като `a*b/2`.
          - `Rectangle` го имплементира като `a*b`.
      - Когато извикаме `area()` през променлива от тип `Figure`, правилната имплементация (на триъгълник или правоъгълник) се извиква автоматично.