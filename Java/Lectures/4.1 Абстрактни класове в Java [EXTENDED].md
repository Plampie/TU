Разбира се. Ето съдържанието за абстрактните класове, интерфейсите и полиморфизма, форматирано по модела на предоставения от вас файл.

# Абстрактни класове, Интерфейси и Полиморфизъм

## Абстрактни класове

Абстрактен клас е клас, деклариран с `abstract`, който може да съдържа както абстрактни (без тяло), така и конкретни (с тяло) методи.

-----

### Деклариране

```java
// Декларация с ключовата дума abstract
public abstract class AbstractClassExample {
    
    // Конкретен метод: има тяло
    public void someMethod() {
        // Statements here
    }

    // Абстрактен метод: без тяло, завършва с ;
    public abstract void firstaAbstractMethod();
}
```

  * `abstract` метод (`firstaAbstractMethod`) съдържа само декларация, но няма имплементация (тяло).
  * Ако един клас има поне един `abstract` метод, класът задължително трябва да бъде деклариран като `abstract`.
  * `someMethod` е конкретен (неабстрактен) метод, тъй като има имплементация (тяло `{}`).

-----

### Наследяване и Имплементация

```java
public abstract class Figure {
    public abstract double area(float a, float b);
}

class Triangle extends Figure {
    @Override
    public double area(float a, float b) {
        return a * b / 2;
    }
}

class Rectangle extends Figure {
    @Override
    public double area(float a, float b) {
        return a * b;
    }
}
```

  * `Figure` е абстрактен клас, който дефинира абстрактно поведение `area`.
  * `Triangle` и `Rectangle` наследяват `Figure` и предоставят *конкретна* имплементация за `area`, тъй като изчислението е различно за всяка фигура. `@Override` показва, че методът се имплементира от родителския клас.

-----

### Важни правила

  * **Абстрактен клас не може да се инстанцира\!** (Не може да се направи `new Figure()`). Може само да се наследява.
  * Ако даден клас наследи абстрактен клас, той **задължително трябва да имплементира всички** абстрактни методи.
      * *Изключение:* Ако класът-наследник също е `abstract`, той не е длъжен да ги имплементира (прехвърля задължението).

-----

### Защо са необходими?

  * Те обобщават функционалност и белези.
  * **Пример:** Клас `Животно` е `abstract`. Няма смисъл да се създава обект "Животно". Наследниците `Куче` и `Котка` са конкретни.
  * Ако `Животно` има `abstract` метод `издаванеНаЗвук()`, `Куче` ще го имплементира като "Бау-бау", а `Котка` като "Мяу-мяу". Абстрактният клас `Животно` не знае какъв звук да издаде.

-----

## Интерфейси

Интерфейсът е подобен на абстрактен клас, но (традиционно) съдържа само абстрактни методи и константни променливи.

-----

### Деклариране

```java
public interface FirstInterface {
    /* * Всички методи по подразбиране са 
     * public abstract.
     * Не е нужно да се изписва.
     */
    void method1(); // еквивалентно на public abstract void method1();
    void method2();
}
```

  * Декларира се с `interface`.
  * Методите **нямат тяло** и по подразбиране са `public abstract`.

-----

### Имплементация

```java
public interface MyInterface {
    public abstract void method1();
    public abstract void method2();
}

public class XYZ implements MyInterface {
    
    // Класът е длъжен да имплементира ВСИЧКИ методи
    public void method1() {
        System.out.println("implementation of method1");
    }

    public void method2() {
        System.out.println("implementation of method2");
    }

    public static void main(String arg[]) {
        MyInterface obj = new XYZ();
        obj.method1();
    }
}
```

  * Клас "наследява" интерфейс с ключовата дума `implements`.
  * Класът `XYZ` **трябва** да имплементира (да напише тяло) за `method1` и `method2`.
  * В `main` метода се вижда как обект от тип `XYZ` се съхранява в променлива от типа на интерфейса (`MyInterface`).

-----

### Интерфейси с променливи

```java
interface Try {
    public int b = 10;
    final int d = 10;
    static int e = 0;
    public static final int c = 10;
    int a = 10; // Всички са идентични
}
```

  * Всички променливи, дефинирани в интерфейс, са **по подразбиране `public static final`** (публични, статични константи).
  * Те **трябва** да бъдат инициализирани по време на декларацията.
  * Стойността им не може да се променя.

-----

### Наследяване на интерфейси

```java
public interface Inf1 {
    public abstract void method1();
}

// Inf2 наследява Inf1
public interface Inf2 extends Inf1 {
    public abstract void method2();
}

// Demo имплементира Inf2 (и индиректно Inf1)
public class Demo implements Inf2 {
    
    // Трябва да имплементира method1 (от Inf1)
    public void method1() {
        // Implementation of method1
    }
    
    // Трябва да имплементира method2 (от Inf2)
    public void method2() {
        // Implementation of method2
    }
}
```

  * Интерфейс може да **наследи** друг интерфейс чрез `extends` (не `implements`).
  * Когато клас `implements` `Inf2`, той трябва да имплементира методите и на `Inf2`, и на всички негови "родители" (в случая `Inf1`).

-----

### Важни правила

  * **Интерфейс не може да се инстанцира\!**
  * **Множествено наследяване:** Един клас може да имплементира **множество интерфейси** (`class MyClass implements Inf1, Inf2`). Това е начинът Java да постигне множествено наследяване на "поведение".
  * **Java 8 `default` методи:** От Java 8 интерфейсите могат да имат и **конкретни** методи, декларирани с `default`. Това позволява добавяне на функционалност по подразбиране.
  * **Конфликт на методи:**
      * Ако два интерфейса имат еднакви методи, класът ги имплементира **само веднъж**.
      * **ГРЕШКА:** Ако два интерфейса имат методи с **еднакво име, но различен тип на връщан резултат**, те не могат да бъдат имплементирани от един и същи клас.

<!-- end list -->

```java
interface A {
    public abstract void aaa();
}
interface B {
    public abstract int aaa(); // Същото име, различен тип (int)
}

// Този клас НЕ може да се компилира
// class Central implements A, B { ... }
```

  * **Конфликт на променливи:** Ако има съвпадащи имена на променливи, те се достъпват статично чрез името на интерфейса (напр. `A.myVar`).

-----

## Полиморфизъм

Полиморфизъм означава "много форми". В ООП това се интерпретира като "един интерфейс – много методи (имплементации)".

-----

### Обяснение

  * Това е способността на различни обекти да извършват **едно и също действие** (извикване на метод) по **различен начин**.
  * **Пример (Превозни средства):**
      * Всички превозни средства (кола, тир, автобус) имат общо действие "движение".
      * Всички имат общ "интерфейс" (волан, скорости, мигачи).
      * Въпреки това, "движението" се извършва по различен начин при всеки (различен двигател, устройство).
  * **Практически пример (от лекцията):**
      * Примерът с `Figure` е полиморфизъм.
      * "Интерфейсът" е методът `area()`.
      * "Многото форми" са различните имплементации:
          * `Triangle` го имплементира като `a*b/2`.
          * `Rectangle` го имплементира като `a*b`.
      * Когато извикаме `area()` през променлива от тип `Figure`, правилната имплементация (на триъгълник или правоъгълник) се извиква автоматично.