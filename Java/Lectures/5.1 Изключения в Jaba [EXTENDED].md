# Изключения в Java

## Изключения (Exceptions)

### Какво е изключение?

  * **Дефиниция:** Изключение (Exception) е събитие, което настъпва по време на **изпълнение** на програмата и затруднява нейното нормално завършване.
  * **Механизъм в Java:** Java позволява дефинирането на специален "код за обработка на изключения" (exception handler), който се изпълнява автоматично при възникване на грешка.

-----

### Йерархия на изключенията

  * ![Logo](http://javac.bg/wp-content/uploads/2015/10/exception5.jpg)

  * Всички изключения в Java са класове, наследници на `Object`.

  * **`Throwable`:** Родителският клас на всички грешки и изключения.

  * **`Error`:**

      * Наследник на `Throwable`.
      * Това са **критични грешки**, при които програмата *не може* да бъде възстановена.
      * "Хвърлят" се от JVM (runtime system).
      * **Примери:** `OutOfMemoryError` (недостиг на памет), `StackOverflowError` (препълване на стека).

  * **Пример (`ErrorExample`):**

    ```java
    public class ErrorExample {
        public static void main(String[] args) {
            ErrorExample err = new ErrorExample();
            err.firstMethod();
        }
        public void firstMethod(){
            this.secondMethod();
        }
        public void secondMethod(){
            this.firstMethod();
        }
    }
    ```

  * **Обяснение на кода:** `firstMethod()` вика `secondMethod()`, а `secondMethod()` вика `firstMethod()`. Това създава безкрайна рекурсия, която бързо препълва стека на паметта.

  * **Резултат (Output):**

    ```
    Exception in thread "main" java.lang.StackOverflowError
        at error.firstMethod(error.java:9)
        at error.secondMethod(error.java:13)
        ...
    ```

-----

### Проверени (Checked) vs. Непроверени (Unchecked) изключения

  * ![Types_of_exeptions](https://rollbar.com/wp-content/uploads/2021/10 types-of-exceptions-in-java-checked-unchecked.png)

  * **Проверени (Checked Exception):**

      * Прихващат се по време на **компилация**.
      * Това са всички наследници на `Exception`, които **НЕ** са наследници на `RuntimeException`.
      * Компилаторът *изисква* те да бъдат обработени (с `try-catch` или `throws`). Ако не са, програмата няма да се компилира (`Compilation error`).

  * **Непроверени (Unchecked Exception):**

      * Прихващат се от JVM по време на **изпълнение**.
      * Това са всички наследници на `RuntimeException`.
      * Компилаторът *не* задължава програмиста да ги обработва.

  * **Важно:** Няма *функционална* разлика между двата типа. Разликата е в това кога се засичат (при компилация или при изпълнение).

-----

### Ключови думи за работа с изключения

Това са петте основни ключови думи:

1.  `try`
2.  `catch`
3.  `finally`
4.  `throws`
5.  `throw`

-----

### Блокът `try-catch`

  * **`try`:** Кодът, който *може* да генерира изключение, се поставя в `try` блок.

  * **`catch`:** След `try` *винаги* трябва да има един или повече `catch` блокове. Всеки `catch` блок обработва специфичен тип изключение.

  * **Пример (Преди `try-catch`):**

    ```java
    // ... (в main метода)
    Scanner scanner = new Scanner(System.in);
    System.out.println("Enter an integer.");
    number = scanner.nextInt(); // Какво става, ако въведем 'A'?
    System.out.println(division(100, number)); // Какво става, ако въведем 0?
    // ...
    public static int division(int a, int b) {
        return a / b;
    }
    ```

  * **Обяснение (Проблем):** Ако потребителят въведе символ вместо число, програмата ще "гръмне" с `InputMismatchException`. Ако въведе 0, ще "гръмне" с `ArithmeticException`.

  * **Пример (С `try-catch`):**

    ```java
    // ... (в main метода, в do-while цикъл)
    try {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Enter an integer.");
        number = scaner.nextInt(); // Критичен момент 1
        System.out.println(division(100, number)); // Критичен момент 2
        result = true;
    } catch (InputMismatchException e) {
        System.out.println("You didn't enter integer.");
    } catch (ArithmeticException e) {
        System.out.println(e.getMessage()); // Ще изпише нещо като "/ by zero"
    } catch (Exception e) { // Най-общ тип изключение
        e.printStackTrace();
    }
    // ...
    ```

  * **Обяснение на кода:**

      * Критичният код е в `try` блока.
      * Ако се въведе не-число, `InputMismatchException` се прихваща и обработва.
      * Ако се въведе 0, `ArithmeticException` се прихваща и обработва.
      * `catch (Exception e)` е "предпазна мрежа" за всички други неочаквани грешки.

  * **Важно (Ред на `catch` блоковете):**

      * Винаги трябва да се прихващат от **по-конкретен** към **по-общ** клас (от наследник към родител).
      * Ако `catch (Exception e)` е пръв, той ще прихване *всичко* (тъй като `ArithmeticException` е наследник на `Exception`) и другите `catch` блокове никога няма да бъдат достигнати, което ще доведе до грешка при компилация.

-----

### Блокът `finally`

  * **Дефиниция:** Блокът `finally` се изпълнява **ВИНАГИ**, независимо дали е възникнало изключение, или не.

  * **Синтаксис:** `try { ... } catch(...) { ... } finally { ... }`

  * **Пример (`FinallyExample`):**

    ```java
    public class FinallyExample {
        public static void main(String[] args) {
            int array[] = new int[5];
            try {
                System.out.println(array[7]); // Генерира грешка
            } catch (ArrayIndexOutOfBoundsException e) {
                System.out.println("Enter a valid index."); // Обработва грешката
            } finally{
                System.out.println("This will printing ever."); // Изпълнява се ВИНАГИ
            }
        }
    }
    ```

  * **Обяснение на кода:** Кодът се опитва да достъпи индекс 7 от масив с 5 елемента. `try` блокът генерира `ArrayIndexOutOfBoundsException`, `catch` блокът го обработва. `finally` блокът се изпълнява след това, гарантирайки, че съобщението "This will printing ever." ще се изпише.

-----

### "Хвърляне" на изключения (`throws` и `throw`)

#### `throws` (Деклариране, че метод *може* да хвърли изключение)

  * **Дефиниция:** Когато един метод може да причини изключение, но не го обработва сам, той може да го "прехвърли" на метода, който го е извикал.

  * Това става чрез добавяне на `throws SomeException` в сигнатурата (декларацията) на метода.

  * **Пример (`throws`):**

    ```java
    public class ExceptionExample {
        public static void main(String[] args) {
            try {
                division(100, 0); // Викащият метод (main) ТРЯБВА да обработи грешката
            } catch (ArithmeticException e) {
                System.out.println("You can't divide by zero!");
            }
        }

        // Методът 'division' ДЕКЛАРИРА, че 'хвърля' грешката
        public static void division(int a, int b) throws ArithmeticException {
            int c = a / b; // Тук възниква грешката
            System.out.println(c);
        }
    }
    ```

  * **Обяснение на кода:** Методът `division` декларира, че "хвърля" `ArithmeticException`. Поради това `main` методът е *длъжен* да постави извикването на `division` в `try-catch` блок.

#### `throw` (Ръчно хвърляне на изключение)

  * **Дефиниция:** Програмистът може *ръчно* да създаде и "хвърли" изключение чрез ключовата дума `throw`.

  * **Код Пример (`throw`):**

    ```java
    // ... (main методът е същият като горния)

    public static void division(int a, int b) throws ArithmeticException {
        if (b == 0) {
            // Ние сами създаваме и хвърляме изключението
            throw new ArithmeticException();
        } else {
            int c = a / b;
            System.out.println(c);
        }
    }
    ```

  * **Обяснение на кода:** Вместо да чакаме JVM да "гръмне" при деленето `a / b`, ние правим проверка. Ако `b` е 0, ние *активно* създаваме нов обект `ArithmeticException` и го хвърляме.

  * **Важно:** Ако ръчно хвърляте (`throw`) изключение, методът *трябва* да го декларира с `throws` (освен ако не е Unchecked Exception).

-----

### Собствени изключения (Custom Exceptions)

  * **Дефиниция:** Можем да създадем наши собствени класове за изключения, когато стандартните не са достатъчно описателни.

  * **Начин:** Създаваме нов клас, който наследява `Exception` (за Checked) или `RuntimeException` (за Unchecked). Обикновено предефинираме метода `getMessage()`.

  * **Пример (Собствен Exception):**

    ```java
    // 1. Дефиниране на собствения клас за изключение
    public class PriceErrorException extends Exception {
        @Override
        public String getMessage(){
            return "Invalid price!";
        }
    }

    // 2. Използване на собственото изключение
    public class Example {
        public static void main(String[] args) {
            try{
                readPriceTv();
            } catch(PriceErrorException e){ // Прихващаме нашия тип грешка
                System.out.println(e.getMessage()); // Извиква нашия предефиниран метод
            }
        }

        private static int readPriceTv() throws PriceErrorException {
            Scanner scanner = new Scanner(System.in);
            int userPrice = scanner.nextInt();
            // Ако цената е извън рамките (100-500), хвърляме НАШАТА грешка
            if(userPrice > 500 || userPrice < 100){
                throw new PriceErrorException();
            }
            return userPrice;
        }
    }
    ```

  * **Обяснение на кода:** Създаден е клас `PriceErrorException`. Методът `readPriceTv` го хвърля (`throw`), ако цената е невалидна. `main` методът го прихваща (`catch`) и отпечатва персонализираното съобщение "Invalid price\!".