# Символни низове. Динамични стрингове. Регулярни изрази.

## Символни низове (String) в Java

  * **Дефиниция:** Символните низове (клас `String`) в Java са поредици от символи (вътрешно `char[]`).
  * **Референция:** `String` е референтен тип (клас), което означава, че променливите пазят референция (адрес) към обект, който се съхранява в паметта (Heap-a).

-----

## Създаване на Стрингове

Има два основни начина:

1.  **Чрез String Literal (литерал):**

      * ```java
          String str = “hello”;
          String srting = “Hi! How are you?”;
        ```
      * Този метод е по-ефективен. Java поддържа "string pool" (басейн от низове). Ако низ със стойност "hello" вече съществува в този "pool", новата променлива `str` просто ще сочи към него, без да се създава нов обект.

2.  **Чрез конструктор (с `new`):**

      * `String str = new String("hello");`
      * Ключовата дума `new` **винаги** принуждава Java да създаде нов обект в Heap-a, дори ако обект със същата стойност ("hello") вече съществува в "string pool"-а.

-----

## Неизменност (Immutability) на String

  * **Най-важна особеност:** Обектите от тип `String` са **неизменни (immutable)**.

  * **Значение:** Веднъж създаден, един `String` обект **никога** не може да бъде променян.

  * **Проблем при конкатенация (съединяване):** Когато "променяте" стринг (напр. в цикъл), вие всъщност не го променяте. На всяка стъпка се създава **изцяло нов** `String` обект в паметта, а старият се изхвърля (по-късно от Garbage Collector).

  * **Обяснение по кода (Проблемният пример):**

    ```java
    String str = "a";
    for(int i = 0; i < 1000000; i++){
        str = str + "a"; // Проблем!
    }
    ```

      * **Обяснение:** Този код е изключително неефективен. В цикъла, на всяка итерация (`str = str + "a"`), се създава нов `String` обект, който е с един символ "a" по-дълъг от предходния. Това води до създаването на 1 милион обекта, което натоварва паметта и процесора.

-----

## Основни операции (методи) над Стрингове

Класът `String` предоставя много готови методи за работа:

  * **`char charAt(int index)`:** Връща символа на зададена позиция (индекс).
  * **`boolean equals(Object obj)`:** Сравнява два стринга за **съвпадение по съдържание** (case-sensitive, т.е. "a" не е равно на "A").
  * **`boolean equalsIgnoreCase(String str)`:** Сравнява два стринга, без да се влияе от малки/големи букви.
  * **`int compareTo(String str)`:** Лексикографско сравнение (като в речник). Връща 0 (ако са равни), отрицателно (ако текущият е "преди" подадения) или положително число.
  * **`boolean startsWith(String prefix)` / `boolean endsWith(String suffix)`:** Проверява дали стрингът започва или завършва с даден префикс/суфикс.
  * **`int indexOf(String str)` / `int lastIndexOf(String str)`:** Връща индекса на първото (или последното) срещане на даден подниз. Връща -1, ако не е намерен.
  * **`String substring(int beginIndex, int endIndex)`:** Връща нов стринг, който е част (подниз) от текущия.
  * **`String concat(String str)`:** Съединява (конкатенира) два стринга. (Операторът `+` прави същото).
  * **`String replace(char old, char new)`:** Замества **всички** срещания на даден символ с нов.
  * **`String replaceAll(String regex, String r)`:** Замества всички части, отговарящи на **регулярен израз** (regex), с нов низ.
  * **`String[] split(String regex)`:** "Разцепва" стринга на масив от стрингове спрямо даден разделител (който също е регулярен израз).
  * **`String toLowerCase()` / `String toUpperCase()`:** Връща нов стринг, в който всички букви са малки/големи.
  * **`String trim()`:** Връща нов стринг, от който са премахнати празните символи (шпации, табулации) в началото и края.

-----

## Конвертиране на String към int и обратно

Това са много чести операции в програмирането.

  * **String към int:**
    Използва се статичният метод `Integer.parseInt()`.

    ```java
    String numberStr = "123";
    int intValue = Integer.parseInt(numberStr);
    // intValue вече съдържа числото 123
    ```

    > **Внимание:** Ако стрингът не може да бъде преобразуван в число (напр. `"123a"` или `"abc"`), този код ще хвърли грешка (Exception) от тип `NumberFormatException`.

  * **int към String:**
    Най-лесният и препоръчителен начин е чрез статичния метод `String.valueOf()`.

    ```java
    int intValue = 42;
    String numberStr = String.valueOf(intValue);
    // numberStr вече съдържа текста "42"
    ```

    *Друг популярен (но по-малко ефективен) метод е "трик" с конкатенация: `String numberStr = "" + intValue;`*

-----

## Динамични низове (StringBuilder и StringBuffer)

  * **Решение на проблема:** За да се избегне неефективното създаване на нови обекти при чести промени, се използват `StringBuilder` или `StringBuffer`.

  * **Характеристика:** Те са **изменми (mutable)**. Промените се извършват върху **същия обект** в паметта.

  * **Основни методи:**

      * **`append(…)`:** Добавя (конкатенира) към края на низа.
      * **`insert(int offset, …)`:** Вмъква на определена позиция.
      * **`delete(int start, int end)`:** Изтрива част от низа.
      * **`replace(int start, int end, String str)`:** Замества част от низа.
      * **`reverse()`:** Обръща низа наобратно.

  * **Разликата между `StringBuilder` и `StringBuffer`:**

    Тази таблица обобщава ключовите разлики между трите класа:

| Характеристика | String | StringBuffer | StringBuilder |
| :--- | :--- | :--- | :--- |
| **Съхранение** | String Pool (ако е 'interned') или Heap | Heap | Heap |
| **Изменимост** | Immutable (Неизменим) | **Mutable (Изменим)** | **Mutable (Изменим)** |
| **Синхронизация** | (Неприложимо) | **Synchronized (Синхронизиран)** | **Non-Synchronized (Несинхронизиран)** |
| **Нишкова безопасност** | Thread Safe (заради неизменност) | **Thread Safe (Безопасен)** | **Not Thread Safe (Не е безопасен)** |
| **Ефективност** | По-малко ефективен (при промени) | По-малко ефективен (заради 'overhead') | **Най-ефективен (без 'overhead')** |

  * **`StringBuffer`** е **thread-safe** (синхронизиран). Това означава, че е по-бавен, защото методите му са заключени за работа от няколко нишки едновременно.
  * **`StringBuilder`** **не е thread-safe**. Той е по-бърз (няма 'overhead' от синхронизация) и е препоръчителен за употреба, когато стрингът се ползва само в рамките на една нишка (в 99% от случаите).

-----

## Регулярни изрази (Regular Expressions - Regex)

  * **Дефиниция:** Регулярният израз е **шаблон (pattern)**, който описва поредица от символи. Използва се за валидация (проверка) или търсене на текст, който отговаря на шаблона.
  * **Пример:** Валидиране на имейл (`xxxx@xxx.xx`) или потребителско име.
  * **Java пакет:** `java.util.regex`.
  * **Основни класове:**
    1.  **`Pattern`:** Представлява компилирания регулярен израз. Създава се статично: `Pattern pattern = Pattern.compile(REGEX_ШАБЛОН);`
    2.  **`Matcher`:** Изпълнява същинското съвпадение (matching) спрямо даден текст. Създава се от `Pattern` обекта: `Matcher matcher = pattern.matcher(ТЕКСТ_ЗА_ПРОВЕРКА);`
    3.  `PatternSyntaxException`: Грешка, ако синтаксисът на шаблона е грешен.

### Синтаксис на Regex (Основни правила)

  * **`[abc]`:** Дефиниция на група. Всеки от изброените символи (a, b **ИЛИ** c).
  * **`[^abc]`:** Отрицание. Всеки символ, **ОСВЕН** a, b или c.
  * **`[a-z]`:** Обхват. Всички малки букви от 'a' до 'z'.
  * **`.` (точка):** Всеки един символ.
  * **`\d`:** Всяка цифра. (Еквивалентно на `[0-9]`).
  * **`\D`:** Всичко, което не е цифра. (Еквивалентно на `[^0-9]`).
  * **`\w`:** "Word" символ. Всяка буква, цифра или долна черта `_`. (Еквивалентно на `[a-zA-Z0-9_]`).
  * **`\W`:** Всичко, което не е "word" символ.
  * **`\s`:** "Whitespace" символ (интервал, нов ред `\n`, табулация `\t`).
  * **`^` (в началото):** Начало на реда/низа.
  * **`$` (в края):** Край на реда/низа.

### Квантификатори (Quantifiers)

  * **`*`:** Нула или повече пъти.
  * **`+`:** Един или повече пъти.
  * **`?`:** Нула или един път.
  * **`{X}`:** Точно `X` пъти.
  * **`{X,Y}`:** Между `X` и `Y` пъти.
  * **`{X,}`:** `X` или повече пъти.
  * **`[СНИМКА]`** (Тук вероятно има снимка, която илюстрира работата на квантификаторите).

### Методи на Matcher

  * **`boolean matches()`:** Проверява дали **целият** низ отговаря **точно** на шаблона.
  * **`boolean find()`:** Търси **следващо** срещане на шаблона някъде **вътре** в низа. Може да се извиква в `while` цикъл, за да намери всички съвпадения.
  * **`boolean lookingAt()`:** Проверява дали низът **започва** с шаблона.
  * **`[СНИМКА]`** (Тук вероятно има снимка, сравняваща `matches()` и `find()`).
  * **`String group()`:** (Използва се след `find()` или `matches()`) Връща текста, който е съвпаднал с шаблона.
  * **`int start()` / `int end()`:** Връщат началния и крайния индекс на намереното съвпадение.

-----

## Обяснения по Кодовете (Примери за Regex)

### Задача 1: Валидатор на Потребителско име

  * **Изисквания:**

      * Може да съдържа малки букви (a-z), цифри (0-9), долна черта `_` или тире `-`.
      * Дължина: от 3 до 15 символа.

  * **Код:**

    ```java
    public class UsernameValidator {
        private Pattern pattern;
        private Matcher matcher;

        // Декларираме шаблона като константа
        private static final String USERNAME_PATTERN = "^[a-z0-9_-]{3,15}$";

        public UsernameValidator() {
            pattern = Pattern.compile(USERNAME_PATTERN); // Компилираме го
        }

        // Метод за валидация
        public boolean validateUserName(final String username) {
            matcher = pattern.matcher(username); // Създаваме matcher за подадения username
            return matcher.matches(); // Връщаме true, ако целият username отговаря
        }
    }
    ```

  * **Обяснение на Регулярния израз `^[a-z0-9_-]{3,15}$`:**

      * **`^`:** Начало на низа.
      * **`[a-z0-9_-]`:** Група от позволени символи (малки букви, цифри, `_` или `-`).
      * **`{3,15}`:** Квантификатор. Горната група от символи трябва да се повтаря между 3 и 15 пъти.
      * **`$`:** Край на низа. (Това, заедно с `^`, гарантира, че *целият* низ се състои *само* от тези символи и е с тази дължина).

### Задача 2: Валидатор на Имейл адрес

  * **Код:**

    ```java
    public class MailValidator {
        private Pattern pattern;
        private Matcher matcher;

        // По-сложен шаблон за имейл
        private static final String EMAIL_PATTERN =
            "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@"
            + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$";

        public EmailValidator() {
            pattern = Pattern.compile(EMAIL_PATTERN);
        }

        public boolean validateMail(final String checkedMail) {
            matcher = pattern.matcher(checkedMail);
            return matcher.matches();
        }
    }
    ```

  * **Обяснение на Регулярния израз (опростено):**

      * `^...` : Започва от началото на низа.
      * `[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*` : Това описва **"потребителската част"** преди `@`. Позволява символи, точки (но не в началото/края) и `+`.
      * `@` : Задължителен символ "кльомба".
      * `[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})` : Това описва **"домейн частта"**. Изисква поне един домейн (`google`, `abv`), последван от нула или повече под-домейни (`.com`, `.co.uk`). Последната част `(\\.[A-Za-z]{2,})` гарантира, че завършва с точка и поне 2 букви (като `.com`, `.bg`, `.net`).
      * `...$` : Свършва в края на низа.