# Работа с файлове в Java

## Въведение в I/O (Входно-изходни операции)

  * **Какво е I/O операция:** Всяка операция, свързана с достъп до ресурс извън програмата (напр. четене от клавиатура, писане на конзола, четене/писане във файл).
  * **Достъп до файлове:** Файловете се намират на диска и се достъпват чрез техния URL адрес (напр. `C://Folder/myFile.doc`).
  * **Механизъм:** За достъп до I/O устройство е нужен интерфейс. Програмата "улавя" входно/изходния поток (stream) от/към ресурса и чете/пише в него.
  * **Проблемът:** При работа с външни ресурси (като файлове) могат да възникнат грешки – файлът е изтрит, повреден, няма връзка и т.н.
  * **Решението в Java:** **Exception Handling** (Обработка на изключения).

## Обработка на изключения (Exception Handling)

  * **`try-catch` блок:** Код, който има риск да предизвика грешка (изключение), се поставя в `try` блок.
  * Ако възникне грешка, изпълнението преминава в `catch` блока, където грешката се обработва.
  * **Синтаксис на кода:**
    ```java
    try {
      // Код, който може да предизвика грешка
    } catch (Exception nameOfExc){
      // Какво да се направи, ако грешката възникне
    }
    ```
  * **Важни изключения при работа с файлове:** `IOException`, `SecurityException`, `NoSuchFileException`, `FileNotFoundException`.

## Създаване на файл

  * **Клас `File`:** Използва се за работа с файлове и директории.
  * **Метод `createNewFile()`:**
      * Създава нов, празен файл, *ако* такъв не съществува.
      * Връща `true`, ако файлът е създаден успешно.
      * Връща `false`, ако файлът вече съществува.
  * **Примерен код (Създаване на файл):**
    ```java
    import java.io.File;
    import java.io.IOException;

    public class CreateFileExample {
      public static void main( String[] args ){
        try {
          File file = new File("C:\\newfile.txt");
          boolean isCreated = file.createNewFile(); // Може да хвърли IOException
          if (isCreated){
            System.out.println("File has been created successfully");
          } else{
            System.out.println("File already present at the specified location");
          }
        } catch (IOException e) {
          System.out.println("Exception Occurred:");
          e.printStackTrace(); // Отпечатва пълния път на грешката
        }
      }
    }
    ```
  * **Обяснение на кода:** Операцията е в `try-catch`, защото създаването на файл може да се провали (напр. липса на права) и да хвърли `IOException`. `e.printStackTrace()` помага за дебъгване, като показва къде точно е възникнала грешката.

## Потоци (Streams) - Четене и Писане

  * За да се пише във файл, трябва да се отвори **изходен поток** (Output Stream) и да се инициализира "писец" (Writer).
  * ![Image](http://javac.bg/wp-content/uploads/2015/11/pik1.jpg)
  * ![Image](http://javac.bg/wp-content/uploads/2015/11/pik21.jpg)

### 1. Байтови потоци (Byte Streams)

  * **Предназначение:** Трансферират 8-битови данни (байтове).
  * **Основни класове:** `FileInputStream` (за четене) и `FileOutputStream` (за писане).
  * **Примерен код (Копиране на файл байт по байт):**
    ```java
    import java.io.*;
    public class CopyFile {
      public static void main(String args[]) throws IOException {
        FileInputStream in = null;
        FileOutputStream out = null;
        try {
          in = new FileInputStream("input.txt"); // Поток за четене
          out = new FileOutputStream("output.txt"); // Поток за писане
          int c;
          // read() връща байт (като int) или -1 при край на файла
          while ((c = in.read()) != -1) {
            out.write(c); // Записва прочетения байт
          }
        } finally {
          // Задължително затваряне на потоците
          if (in != null) {
            in.close();
          }
          if (out != null) {
            out.close();
          }
        }
      }
    }
    ```
  * **Обяснение на кода:**
      * **`finally` блок:** Този блок се изпълнява *винаги*, независимо дали е възникнала грешка в `try` блока.
      * **`close()`:** Критично важно е отворените потоци да се затворят. `finally` гарантира, че това ще се случи, за да се освободят ресурсите.

### 2. Знакови потоци (Character Streams)

  * **Предназначение:** Трансферират 16-битови Unicode данни (символи).
  * **Основни класове:** `FileReader` и `FileWriter`.
  * **Разлика:** Те вътрешно ползват `FileInputStream/FileOutputStream`, но четат/пишат по 2 байта (един `char`) наведнъж, което ги прави идеални за работа с текст.

### 3. Примерен код (`FileInputStream` и `FileOutputStream`)

  * **Инициализация (2 начина):**
    1.  `InputStream f = new FileInputStream("C:/java/hello");` (със String)
    2.  `File f = new File("C:/java/hello"); InputStream f = new FileInputStream(f);` (с File обект)
  * **Примерен код (Запис и четене на масив от байтове):**
    ```java
    import java.io.*;
    public class FileExample{
      public static void main(String args[]){
        try{
          byte[] writeArr = {1,2,3,4,5};
          OutputStream os = new FileOutputStream("test.txt");
          for(int i = 0; i < writeArr.length ; i++){
            os.write( writeArr[i] ); // Записва всеки байт от масива
          }
          os.close();

          InputStream is = new FileInputStream("test.txt");
          int size = is.available(); // Взима броя налични байтове
          for(int i=0; i< size; i++){
            // Чете байт и го превръща в символ за принтиране
            System.out.print((char)is.read() + " ");
          }
          is.close();
        }catch(IOException e){
          System.out.print("Exception");
        }
      }
    }
    ```

## Буферирани потоци (Buffered Streams)

  * **Проблем:** Четене/писане директно от диска "символ по символ" е бавно.
  * **Решение (Буфериране):** Четaт се *големи порции* данни наведнъж във временна памет (буфер). Следващите операции четат от този бърз буфер, а не от бавния диск.
  * **Резултат:** Значително по-бързи I/O операции.

### 1. Четене с `BufferedReader`

  * **Предназначение:** Буферирано четене на **текст (символи)**. (За байтове се ползва `BufferedInputStream`).
  * "Обвива" друг `Reader` (напр. `FileReader`).
  * **Инициализация (Код):**
    ```java
    // Стандартна
    BufferedReader buffReader = new BufferedReader(new FileReader("D:\\someFile.txt"));

    // Със зададен размер на буфера (напр. 5KB)
    int buffSize = 5 * 1024; // Препоръчително кратно на 1024
    BufferedReader buffReader = new BufferedReader(new FileReader("D:\\someFile.txt"), buffSize);
    ```
  * **Ключов метод: `readLine()`:**
      * Чете цял ред текст (до знака за нов ред `\n`).
      * Връща `String` със съдържанието на реда.
      * Връща `null`, когато стигне края на файла.
  * **Примерен код (Четене ред по ред с `finally`):**
    ```java
    public class BuffExample{
      public static void main(String[] args) {
        BufferedReader br = null;
        try {
          String currentLine;
          br = new BufferedReader(new FileReader("D:\\someFile.txt"));
          // Цикълът върти, докато readLine() не върне null
          while ((currentLine = br.readLine()) != null) {
            System.out.println(currentLine);
          }
        } catch (IOException e) {
          e.printStackTrace();
        } finally {
          try {
            if (br != null) br.close(); // Затваряне в
          } catch (IOException ex) {
            ex.printStackTrace();
          }
        }
      }
    }
    ```
  * **Обяснение на кода:** `finally` блокът е сложен, защото самото затваряне (`br.close()`) също може да хвърли `IOException`.

### 2. Затваряне с `try-with-resources` (от Java 7)

  * **`try-with-resources`:** По-модерен и лесен начин за работа с ресурси (като потоци), които имплементират `AutoCloseable`.
  * Ресурсът се декларира *в скобите* след `try`.
  * Java автоматично ще извика `.close()` на ресурса в края на `try` блока, **без да е нужен `finally` блок**.
  * **Примерен код (с `try-with-resources`):**
    ```java
    public class BuffCloseExample{
      public static void main(String[] args) throws IOException {
        Reader reader = new FileReader("D://someFile.txt");
        // 'buffReader' е деклариран в скобите
        try(BufferedReader buffReader = new BufferedReader(reader)){
          String line = buffReader.readLine();
          while(line != null) {
            line = buffReader.readLine(); // (бел.: статията има логическа грешка тук, прочетете коментарите към нея)
            System.out.println(line);
          }
        }
        // Тук 'buffReader' и 'reader' се затварят автоматично!
      }
    }
    ```
  * **Обяснение на кода:** Затварянето на `BufferedReader` автоматично затваря и `Reader`-a, който той обвива.

### 3. Писане с `BufferedWriter`

  * **Предназначение:** Буферирано писане на **текст (символи)**.
  * **Инициализация (Код):**
    ```java
    int bufferSize = 5 * 1024;
    BufferedWriter buffWriter = new BufferedWriter(new FileWriter("D:\\someFolder\\someFile.txt"), bufferSize);
    ```
  * **Ключови методи:**
      * `newLine()`: Добавя знак за нов ред (независим от OS).
      * `flush()`: **Много важно\!** Принуждава буфера да запише всичко, което е събрал, веднага във файла. Без това рискувате част от данните да останат в паметта, ако програмата приключи.
  * **Примерен код (Писане с `BufferedWriter`):**
    ```java
    public class BuffWriterExample {
      public static void main(String[] args) {
        BufferedWriter buffWriter = null;
        FileWriter fileWriter = null;
        try {
          String textToBeWritten = "Some text..";
          File file = new File("D://someNewFile.txt");
          fileWriter = new FileWriter(file.getAbsoluteFile());
          buffWriter = new BufferedWriter(fileWriter);
          buffWriter.write(textToBeWritten);
          buffWriter.flush(); // Гарантираме записа
          System.out.println("Ready!");
        } catch (IOException e) {
          e.printStackTrace();
        }finally{
          // Трябва да затворим и двата потока
          if(buffWriter != null ){
            try {
              buffWriter.close();
            } catch (IOException e) { e.printStackTrace(); }
          }
          if(fileWriter != null){
            try {
              fileWriter.close();
            } catch (IOException e) { e.printStackTrace(); }
          }
        }
      }
    }
    ```
  * **Обяснение на кода:** Отново се ползва сложен `finally` блок за затваряне на двата потока (`Writer`-a и `BufferedWriter`-a). Този код би бил много по-чист с `try-with-resources`.