# Линейни структори от данни

### 1. Въведение в структурите от данни

  * **Същност:** Математически и логически модел за организация на данни. Познаването им води до по-ефективен код.
  * **Масиви:** Най-познатата линейна структура. Елементите са последователни в паметта и се достъпват чрез индекс.

![Logo](https://codegym.cc/bg/groups/posts/bg.142.masivi-v-java)

-----

### 2. Свързан списък (LinkedList)

  * **Дефиниция:** Множество от елементи, разположени произволно в паметта. Всеки елемент пази адреса на следващия.
  * **Сравнение с масив:**
      * *Предимства:* Лесно добавяне/изтриване; не изисква голям блок последователна памет.
      * *Недостатъци:* По-бавен достъп; изисква повече памет (за пазене на адресите); няма директен достъп по индекс.

  * **Реализация в Java:** Клас `LinkedList`, имплементиращ интерфейс `List`.
  * **Основни методи:**
      * `add(Element)` – добавяне.
      * `remove(Object/index)` – премахване.
      * `get(index)` – взимане на елемент.
      * `contains(Object)` – проверка за наличие.

#### Код: Демонстрация на LinkedList

```java
LinkedList ll = new LinkedList();
ll.add("I");
ll.add("am");
ll.add("example");
ll.add("!");
// Списъкът сега е: [I, am, example, !]

ll.remove("!"); // Премахва по обект
ll.remove(2);   // Премахва елемента на индекс 2 ("example")
// Резултат: [I, am]

ll.removeFirst(); // Премахва първия
ll.removeLast();  // Премахва последния
// Резултат: [] (празен списък)
```

**Обяснение:** Кодът показва динамичната природа на списъка. Първоначално се пълни с 4 думи. Методът `remove("!")` премахва конкретния символ, а `remove(2)` премахва думата "example" (тъй като е на 3-та позиция, индекс 2). Накрая методите за начало и край изчистват списъка напълно.

  * **Generics (Шаблони):** Препоръчително е използването на `LinkedList<String>`, за да се избегне нуждата от преобразуване на типове (casting) и грешки, тъй като стандартният списък работи с тип `Object`.

-----

### 3. Динамичен масив (ArrayList)

  * **Същност:** Хибрид между масив и свързан списък. Позволява добавяне/изтриване, като пази част от елементите свободни (буфер).
  * **Предимства/Недостатъци:** Предпочитан от програмистите, но ако капацитетът се надвиши, целият масив се презаписва на ново място в паметта (бавна операция).
  * **Важно:** Работи само с референтни типове (String, Integer), разположени в Heap паметта.

![Logo](https://www.scientecheasy.com/2020/09/use-of-arraylist-in-java.html/)


#### Код: Работа с ArrayList

```java
List listA = new ArrayList();
listA.add("First element");
listA.add("Third element");
listA.add(0, "element 0"); // Вмъкване на конкретна позиция
```

**Обяснение:** Методът `add` е претоварен. Може да добавя в края, но ако му се подаде индекс (като `0` в примера), той "избутва" останалите елементи и вмъква новия най-отпред.

-----

### 4. Стек (Stack)

  * **Принцип:** **LIFO** (Last In, First Out) – Последен влязъл, първи излязъл.
  * **Аналогия:** Кутия с книги – последната сложена книга се вади първа.
  * **Основни методи:**
      * `push(T)` – добавя на върха.
      * `pop()` – вади и премахва от върха.
      * `peek()` – само поглежда върха без да премахва.


#### Код: Демонстрация на Stack

```java
Stack cars = new Stack();
cars.push("Honda");
cars.push("Opel");
cars.push("Mazda");
cars.push("Audi"); // Audi е последната добавена (най-отгоре)

System.out.println(cars.peek()); 
```

> **Резултат:** `Audi`.
> **Обяснение:** Тъй като стекът работи на принципа LIFO, методът `peek()` връща последния добавен елемент ("Audi"), който стои на върха на "купчината".

-----

### 5. Опашка (Queue)

  * **Принцип:** **FIFO** (First In, First Out) – Първи влязъл, първи излязъл.
  * **Реализация:** Интерфейс `Queue` (често реализиран чрез `LinkedList`).
  * **Основни методи:** `offer()` (добавяне), `poll()` (взимане и махане), `peek()` (поглеждане).


#### Код: Демонстрация на Queue (сравнение със Stack)

```java
Queue cars = new LinkedList();
cars.offer("Honda"); // Honda влиза първа
cars.offer("Opel");
cars.offer("Mazda");
cars.offer("Audi");

System.out.println(cars.peek());
```

**Резултат:** `Honda`.
**Обяснение:** За разлика от стека, при опашката `peek()` връща елемента, който е чакал най-дълго (първия добавен) – в случая "Honda".

-----

### 6. Сортиране и Comparator

  * **Цел:** Сравняване и подреждане на обекти, които не са числа или стрингове (напр. потребителски класове).
  * **Механизъм:** Използва се `Collections.sort()` заедно с интерфейса `Comparator`, където се имплементира методът `compare(obj1, obj2)`.

#### Код: Сортиране на Клиенти (по име и години)

Даден е клас `Customer` с полета `name` и `years`.

**Вариант 1: Сортиране по име**

```java
Collections.sort(listOfCustomers, new Comparator() {
    public int compare(Customer o1, Customer o2) {
        // Сравнява имената като стрингове
        return o1.name.toUpperCase().compareTo(o2.name.toUpperCase());
    }
});
```

Списъкът се подрежда: Adam, Bob, Marry, Saly. Използва се вграденият `compareTo` на String класа.

**Вариант 2: Сортиране по години**

```java
Comparator customerYearComparator = new Comparator() {
    public int compare(Customer o1, Customer o2) {
        // Вади годините на втория от първия за възходящ ред
        return o1.years - o2.years;
    }
};
Collections.sort(listOfCustomers, customerYearComparator);
```

Резултатът е подредба по възраст: Bob (15), Adam (18), Saly (19), Marry (21). Логиката `o1.years - o2.years` връща отрицателно число, ако първият е по-млад, което казва на сортача да го постави по-напред.