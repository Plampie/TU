# ХЕШ-ФУНКЦИИ И ХЕШИРАНЕ

### 1\. Теоретична основа

  * **Дефиниция:** Хеш функцията е математическа функция, която преобразува входни данни с произволна дължина в изходен низ с фиксирана дължина (хеш).
  * **Свойства:**
      * **Еднопосочност:** От хеша не могат да се възстановят оригиналните данни.
      * **Колизия:** Ситуация, при която различни входни данни генерират един и същ хеш.
  * **Приложение:** Криптография, проверка на интегритет и **структури от данни** (за бързо търсене и сравнение).

-----

### 2\. Хеширане в Java (`hashCode`)

Всеки обект в Java има методи `hashCode()` и `equals()`, наследени от базовия клас `Object`.

  * **Проблемът с `hashCode` по подразбиране:**
      * Той връща цяло число, базирано на **адреса в паметта**.
      * Два обекта с еднакви полета (данни) ще имат *различни* хеш кодове, ако са създадени отделно с `new`.

#### Код: Демонстрация на проблема

```java
Person p1 = new Person("Ivan", "Ivanov", 25);
Person p2 = new Person("Ivan", "Ivanov", 25);

// p1 и p2 имат еднакви данни, но са различни обекти в паметта.
System.out.println(p1.hashCode()); // Пример: 5282812
System.out.println(p2.hashCode()); // Пример: 3198717 (РАЗЛИЧЕН!)
```

> **Обяснение:** Тъй като не сме пренаписали (override) метода, Java използва адреса в паметта. Това ни пречи да третираме `p1` и `p2` като "един и същ човек" логически, което е проблем за колекциите.

  * **Решението:** Предефиниране на `hashCode()`, така че да зависи от данните (полетата), а не от адреса.

#### Код: Правилно предефиниране

```java
@Override
public int hashCode() {
    int result = 240;
    // Използваме хеш кодовете на вътрешните полета (String, int)
    result = result + this.firstName.hashCode();
    result = result + this.familyName.hashCode();
    result = result * this.years;
    return result; 
}
```

> **Обяснение:** Сега, ако създадем двама души с име "Ivan" и еднакви години, формулата ще върне едно и също число и за двамата, независимо от паметта.

-----

### 3\. Сравняване на обекти (`equals`)

За да работят коректно колекциите (като `HashMap`), трябва да се спазва контрактът между `hashCode` и `equals`.

  * **Контракт:**
    1.  Ако два обекта са равни (`equals` връща true) -\> задължително имат еднакъв `hashCode`.
    2.  Ако имат еднакъв `hashCode` -\> не е задължително да са равни (заради колизиите).

#### Код: Предефиниране на equals

Стандартният `equals` сравнява само референциите (дали сочат към едно място в паметта). Ние искаме логическо сравнение по съдържание:

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true; // 1. Дали е същият обект в паметта?
    if (obj == null) return false; // 2. Дали не е null?
    if (getClass() != obj.getClass()) return false; // 3. Дали са от един клас?
    
    Person other = (Person) obj;
    // 4. Сравняване поле по поле
    if (!firstName.equals(other.firstName)) return false;
    if (years != other.years) return false;
    return true;
}
```

> **Обяснение:** Този код гарантира, че два обекта са "равни", ако имената и годините им съвпадат.

-----

### 4\. HashMap (Асоциативен масив)

  * **Същност:** Структура, пазеща двойки **Ключ-Стойност** (`Key-Value`). Аналогия с речник (Дума -\> Превод).
  * **Декларация:** `HashMap<KeyType, ValueType> map = new HashMap<>();`
  * **Вмъкване:** `map.put(key, value);` – ако ключът вече съществува, старата стойност се заменя.
  * **Търсене:** `map.get(key);` – връща стойността или `null`, ако няма такъв ключ.

#### Код: Търсене с потребителски обект като КЛЮЧ (Капанът)

В примера се създава `HashMap`, където ключът е обект `Name`, а стойността е `Person`.

```java
Map<Name, Person> mapOfPeople = new HashMap<Name, Person>();

// Създаваме ключ и го добавяме
Name name1 = new Name("Ivan", "Ivanov", "Ivanov");
mapOfPeople.put(name1, p1);

// Опитваме се да намерим човека с НОВ обект за ключ със същите данни
Person found = mapOfPeople.get(new Name("Ivan", "Ivanov", "Ivanov"));

// Резултат: found e NULL (не е намерен)
```

> **Обяснение на проблема:** Търсенето се проваля (`null`), защото въпреки че данните "Ivan Ivanov" са същите, новият обект `new Name(...)` има различен хеш код по подразбиране (ако не сме предефинирали `hashCode` в класа `Name`). HashMap използва хеша, за да намери позицията на записа. Тъй като хешовете са различни, той не намира нищо.
> **Извод:** Винаги предефинирайте `hashCode` и `equals` за класове, които ще ползвате като Ключове\!

-----

### 5\. Обхождане (Итерация) на HashMap

Тъй като HashMap няма индекси (0, 1, 2...), обхождането става чрез итератор върху множеството от записи (`entrySet`).

#### Код: Итерация

```java
// entrySet() връща множество от всички двойки (Entries)
Iterator it = mapOfPeople.entrySet().iterator();

while (it.hasNext()) {
    Map.Entry pair = (Map.Entry) it.next();
    
    // Достъпваме ключа и стойността отделно
    System.out.println("Key: " + pair.getKey()); 
    System.out.println("Value: " + pair.getValue());
}
```

> **Обяснение:** `Map.Entry` е вложен интерфейс, който представлява една отделна двойка (Ключ-Стойност). Чрез `getKey()` и `getValue()` извличаме данните от текущия елемент на цикъла.

### 6\. Характеристики на HashMap

  * **Бързина:** Константно време за достъп (O(1)) при добра реализация на хеш функцията.
  * **Параметри:**
      * `Initial Capacity`: Начален размер на масива отдолу (подразбиране 16).
      * `Load Factor`: Коефициент на запълване (подразбиране 0.75 или 75%), след който структурата автоматично се разширява (resize).
  * **Ред:** Не гарантира запазване на реда на добавяне на елементите.